'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Compressor;

var _zstream = require('pako/lib/zlib/zstream');

var _zstream2 = _interopRequireDefault(_zstream);

var _deflate = require('pako/lib/zlib/deflate');

var _inflate = require('pako/lib/zlib/inflate');

var _messages = require('pako/lib/zlib/messages.js');

var _messages2 = _interopRequireDefault(_messages);

var _constants = require('pako/lib/zlib/constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const CHUNK_SIZE = 16384;
const WINDOW_BITS = 15;

/**
 * Handles de-/compression via #inflate() and #deflate(), calls you back via #deflatedReady() and #inflatedReady().
 * The chunk we get from deflater is actually a view of a 16kB arraybuffer, so we need to copy the relevant parts
 * memory to a new arraybuffer.
 */
function Compressor(inflatedReady, deflatedReady) {
  this.inflatedReady = inflatedReady;
  this.deflatedReady = deflatedReady;
  this._inflate = inflater(chunk => this.inflatedReady(chunk.buffer.slice(chunk.byteOffset, chunk.byteOffset + chunk.length)));
  this._deflate = deflater(chunk => this.deflatedReady(chunk.buffer.slice(chunk.byteOffset, chunk.byteOffset + chunk.length)));
}

Compressor.prototype.inflate = function (buffer) {
  this._inflate(new Uint8Array(buffer));
};

Compressor.prototype.deflate = function (buffer) {
  this._deflate(new Uint8Array(buffer));
};

function deflater(emit) {
  const stream = new _zstream2.default();
  let status = (0, _deflate.deflateInit2)(stream, _constants.Z_DEFAULT_COMPRESSION, _constants.Z_DEFLATED, WINDOW_BITS, 8, _constants.Z_DEFAULT_STRATEGY);
  if (status !== _constants.Z_OK) {
    throw new Error('Problem initializing deflate stream: ' + _messages2.default[status]);
  }

  return function (data) {
    if (data === undefined) return emit();

    // Attach the input data
    stream.input = data;
    stream.next_in = 0;
    stream.avail_in = stream.input.length;

    let status;
    let output;
    let start;
    let ret = true;

    do {
      // When the stream gets full, we need to create new space.
      if (stream.avail_out === 0) {
        stream.output = new Uint8Array(CHUNK_SIZE);
        start = stream.next_out = 0;
        stream.avail_out = CHUNK_SIZE;
      }

      // Perform the deflate
      status = (0, _deflate.deflate)(stream, _constants.Z_SYNC_FLUSH);
      if (status !== _constants.Z_STREAM_END && status !== _constants.Z_OK) {
        throw new Error('Deflate problem: ' + _messages2.default[status]);
      }

      // If the output buffer got full, flush the data.
      if (stream.avail_out === 0 && stream.next_out > start) {
        output = stream.output.subarray(start, start = stream.next_out);
        ret = emit(output);
      }
    } while ((stream.avail_in > 0 || stream.avail_out === 0) && status !== _constants.Z_STREAM_END);

    // Emit whatever is left in output.
    if (stream.next_out > start) {
      output = stream.output.subarray(start, start = stream.next_out);
      ret = emit(output);
    }
    return ret;
  };
}

function inflater(emit) {
  let stream = new _zstream2.default();

  const status = (0, _inflate.inflateInit2)(stream, WINDOW_BITS);
  if (status !== _constants.Z_OK) {
    throw new Error('Problem initializing inflate stream: ' + _messages2.default[status]);
  }

  return function (data) {
    if (data === undefined) return emit();

    let start;
    stream.input = data;
    stream.next_in = 0;
    stream.avail_in = stream.input.length;

    let status, output;
    let ret = true;

    do {
      if (stream.avail_out === 0) {
        stream.output = new Uint8Array(CHUNK_SIZE);
        start = stream.next_out = 0;
        stream.avail_out = CHUNK_SIZE;
      }

      status = (0, _inflate.inflate)(stream, _constants.Z_NO_FLUSH);
      if (status !== _constants.Z_STREAM_END && status !== _constants.Z_OK) {
        throw new Error('inflate problem: ' + _messages2.default[status]);
      }

      if (stream.next_out) {
        if (stream.avail_out === 0 || status === _constants.Z_STREAM_END) {
          output = stream.output.subarray(start, start = stream.next_out);
          ret = emit(output);
        }
      }
    } while (stream.avail_in > 0 && status !== _constants.Z_STREAM_END);

    if (stream.next_out > start) {
      output = stream.output.subarray(start, start = stream.next_out);
      ret = emit(output);
    }

    return ret;
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jb21wcmVzc2lvbi5qcyJdLCJuYW1lcyI6WyJDb21wcmVzc29yIiwiQ0hVTktfU0laRSIsIldJTkRPV19CSVRTIiwiaW5mbGF0ZWRSZWFkeSIsImRlZmxhdGVkUmVhZHkiLCJfaW5mbGF0ZSIsImluZmxhdGVyIiwiY2h1bmsiLCJidWZmZXIiLCJzbGljZSIsImJ5dGVPZmZzZXQiLCJsZW5ndGgiLCJfZGVmbGF0ZSIsImRlZmxhdGVyIiwicHJvdG90eXBlIiwiaW5mbGF0ZSIsIlVpbnQ4QXJyYXkiLCJkZWZsYXRlIiwiZW1pdCIsInN0cmVhbSIsIlpTdHJlYW0iLCJzdGF0dXMiLCJaX0RFRkFVTFRfQ09NUFJFU1NJT04iLCJaX0RFRkxBVEVEIiwiWl9ERUZBVUxUX1NUUkFURUdZIiwiWl9PSyIsIkVycm9yIiwibWVzc2FnZXMiLCJkYXRhIiwidW5kZWZpbmVkIiwiaW5wdXQiLCJuZXh0X2luIiwiYXZhaWxfaW4iLCJvdXRwdXQiLCJzdGFydCIsInJldCIsImF2YWlsX291dCIsIm5leHRfb3V0IiwiWl9TWU5DX0ZMVVNIIiwiWl9TVFJFQU1fRU5EIiwic3ViYXJyYXkiLCJaX05PX0ZMVVNIIl0sIm1hcHBpbmdzIjoiOzs7OztrQkFrQndCQSxVOztBQWxCeEI7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBTUEsTUFBTUMsYUFBYSxLQUFuQjtBQUNBLE1BQU1DLGNBQWMsRUFBcEI7O0FBRUE7Ozs7O0FBS2UsU0FBU0YsVUFBVCxDQUFxQkcsYUFBckIsRUFBb0NDLGFBQXBDLEVBQW1EO0FBQ2hFLE9BQUtELGFBQUwsR0FBcUJBLGFBQXJCO0FBQ0EsT0FBS0MsYUFBTCxHQUFxQkEsYUFBckI7QUFDQSxPQUFLQyxRQUFMLEdBQWdCQyxTQUFTQyxTQUFTLEtBQUtKLGFBQUwsQ0FBbUJJLE1BQU1DLE1BQU4sQ0FBYUMsS0FBYixDQUFtQkYsTUFBTUcsVUFBekIsRUFBcUNILE1BQU1HLFVBQU4sR0FBbUJILE1BQU1JLE1BQTlELENBQW5CLENB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UUFBN0MsQ0FBVDtBQUNBRixnQkFBTWpCLEtBQUtlLE1BQUwsQ0FBTjtBQUNEO0FBQ0Y7QUFDRixLQWxCRCxRQWtCVWQsT0FBT2EsUUFBUCxHQUFrQixDQUFuQixJQUF5QlgsV0FBV2tCLHVCQWxCN0M7O0FBb0JBLFFBQUlwQixPQUFPa0IsUUFBUCxHQUFrQkgsS0FBdEIsRUFBNkI7QUFDM0JELGVBQVNkLE9BQU9jLE1BQVAsQ0FBY08sUUFBZCxDQUF1Qk4sS0FBdkIsRUFBOEJBLFFBQVFmLE9BQU9rQixRQUE3QyxDQUFUO0FBQ0FGLFlBQU1qQixLQUFLZSxNQUFMLENBQU47QUFDRDs7QUFFRCxXQUFPRSxHQUFQO0FBQ0QsR0FyQ0Q7QUFzQ0QiLCJmaWxlIjoiY29tcHJlc3Npb24uanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgWlN0cmVhbSBmcm9tICdwYWtvL2xpYi96bGliL3pzdHJlYW0nXG5pbXBvcnQgeyBkZWZsYXRlSW5pdDIsIGRlZmxhdGUgfSBmcm9tICdwYWtvL2xpYi96bGliL2RlZmxhdGUnXG5pbXBvcnQgeyBpbmZsYXRlLCBpbmZsYXRlSW5pdDIgfSBmcm9tICdwYWtvL2xpYi96bGliL2luZmxhdGUnXG5pbXBvcnQgbWVzc2FnZXMgZnJvbSAncGFrby9saWIvemxpYi9tZXNzYWdlcy5qcydcbmltcG9ydCB7XG4gIFpfTk9fRkxVU0gsIFpfU1lOQ19GTFVTSCwgWl9PSyxcbiAgWl9TVFJFQU1fRU5ELCBaX0RFRkFVTFRfQ09NUFJFU1NJT04sXG4gIFpfREVGQVVMVF9TVFJBVEVHWSwgWl9ERUZMQVRFRFxufSBmcm9tICdwYWtvL2xpYi96bGliL2NvbnN0YW50cydcblxuY29uc3QgQ0hVTktfU0laRSA9IDE2Mzg0XG5jb25zdCBXSU5ET1dfQklUUyA9IDE1XG5cbi8qKlxuICogSGFuZGxlcyBkZS0vY29tcHJlc3Npb24gdmlhICNpbmZsYXRlKCkgYW5kICNkZWZsYXRlKCksIGNhbGxzIHlvdSBiYWNrIHZpYSAjZGVmbGF0ZWRSZWFkeSgpIGFuZCAjaW5mbGF0ZWRSZWFkeSgpLlxuICogVGhlIGNodW5rIHdlIGdldCBmcm9tIGRlZmxhdGVyIGlzIGFjdHVhbGx5IGEgdmlldyBvZiBhIDE2a0IgYXJyYXlidWZmZXIsIHNvIHdlIG5lZWQgdG8gY29weSB0aGUgcmVsZXZhbnQgcGFydHNcbiAqIG1lbW9yeSB0byBhIG5ldyBhcnJheWJ1ZmZlci5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ29tcHJlc3NvciAoaW5mbGF0ZWRSZWFkeSwgZGVmbGF0ZWRSZWFkeSkge1xuICB0aGlzLmluZmxhdGVkUmVhZHkgPSBpbmZsYXRlZFJlYWR5XG4gIHRoaXMuZGVmbGF0ZWRSZWFkeSA9IGRlZmxhdGVkUmVhZHlcbiAgdGhpcy5faW5mbGF0ZSA9IGluZmxhdGVyKGNodW5rID0+IHRoaXMuaW5mbGF0ZWRSZWFkeShjaHVuay5idWZmZXIuc2xpY2UoY2h1bmsuYnl0ZU9mZnNldCwgY2h1bmsuYnl0ZU9mZnNldCArIGNodW5rLmxlbmd0aCkpKVxuICB0aGlzLl9kZWZsYXRlID0gZGVmbGF0ZXIoY2h1bmsgPT4gdGhpcy5kZWZsYXRlZFJlYWR5KGNodW5rLmJ1ZmZlci5zbGljZShjaHVuay5ieXRlT2Zmc2V0LCBjaHVuay5ieXRlT2Zmc2V0ICsgY2h1bmsubGVuZ3RoKSkpXG59XG5cbkNvbXByZXNzb3IucHJvdG90eXBlLmluZmxhdGUgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gIHRoaXMuX2luZmxhdGUobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSlcbn1cblxuQ29tcHJlc3Nvci5wcm90b3R5cGUuZGVmbGF0ZSA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgdGhpcy5fZGVmbGF0ZShuZXcgVWludDhBcnJheShidWZmZXIpKVxufVxuXG5mdW5jdGlvbiBkZWZsYXRlciAoZW1pdCkge1xuICBjb25zdCBzdHJlYW0gPSBuZXcgWlN0cmVhbSgpXG4gIGxldCBzdGF0dXMgPSBkZWZsYXRlSW5pdDIoc3RyZWFtLCBaX0RFRkFVTFRfQ09NUFJFU1NJT04sIFpfREVGTEFURUQsIFdJTkRPV19CSVRTLCA4LCBaX0RFRkFVTFRfU1RSQVRFR1kpXG4gIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2JsZW0gaW5pdGlhbGl6aW5nIGRlZmxhdGUgc3RyZWFtOiAnICsgbWVzc2FnZXNbc3RhdHVzXSlcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHJldHVybiBlbWl0KClcblxuICAgIC8vIEF0dGFjaCB0aGUgaW5wdXQgZGF0YVxuICAgIHN0cmVhbS5pbnB1dCA9IGRhdGFcbiAgICBzdHJlYW0ubmV4dF9pbiA9IDBcbiAgICBzdHJlYW0uYXZhaWxfaW4gPSBzdHJlYW0uaW5wdXQubGVuZ3RoXG5cbiAgICBsZXQgc3RhdHVzXG4gICAgbGV0IG91dHB1dFxuICAgIGxldCBzdGFydFxuICAgIGxldCByZXQgPSB0cnVlXG5cbiAgICBkbyB7XG4gICAgICAvLyBXaGVuIHRoZSBzdHJlYW0gZ2V0cyBmdWxsLCB3ZSBuZWVkIHRvIGNyZWF0ZSBuZXcgc3BhY2UuXG4gICAgICBpZiAoc3RyZWFtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzdHJlYW0ub3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkoQ0hVTktfU0laRSlcbiAgICAgICAgc3RhcnQgPSBzdHJlYW0ubmV4dF9vdXQgPSAwXG4gICAgICAgIHN0cmVhbS5hdmFpbF9vdXQgPSBDSFVOS19TSVpFXG4gICAgICB9XG5cbiAgICAgIC8vIFBlcmZvcm0gdGhlIGRlZmxhdGVcbiAgICAgIHN0YXR1cyA9IGRlZmxhdGUoc3RyZWFtLCBaX1NZTkNfRkxVU0gpXG4gICAgICBpZiAoc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBaX09LKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVmbGF0ZSBwcm9ibGVtOiAnICsgbWVzc2FnZXNbc3RhdHVzXSlcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIG91dHB1dCBidWZmZXIgZ290IGZ1bGwsIGZsdXNoIHRoZSBkYXRhLlxuICAgICAgaWYgKHN0cmVhbS5hdmFpbF9vdXQgPT09IDAgJiYgc3RyZWFtLm5leHRfb3V0ID4gc3RhcnQpIHtcbiAgICAgICAgb3V0cHV0ID0gc3RyZWFtLm91dHB1dC5zdWJhcnJheShzdGFydCwgc3RhcnQgPSBzdHJlYW0ubmV4dF9vdXQpXG4gICAgICAgIHJldCA9IGVtaXQob3V0cHV0KVxuICAgICAgfVxuICAgIH0gd2hpbGUgKChzdHJlYW0uYXZhaWxfaW4gPiAwIHx8IHN0cmVhbS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gWl9TVFJFQU1fRU5EKVxuXG4gICAgLy8gRW1pdCB3aGF0ZXZlciBpcyBsZWZ0IGluIG91dHB1dC5cbiAgICBpZiAoc3RyZWFtLm5leHRfb3V0ID4gc3RhcnQpIHtcbiAgICAgIG91dHB1dCA9IHN0cmVhbS5vdXRwdXQuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ID0gc3RyZWFtLm5leHRfb3V0KVxuICAgICAgcmV0ID0gZW1pdChvdXRwdXQpXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmZsYXRlciAoZW1pdCkge1xuICBsZXQgc3RyZWFtID0gbmV3IFpTdHJlYW0oKVxuXG4gIGNvbnN0IHN0YXR1cyA9IGluZmxhdGVJbml0MihzdHJlYW0sIFdJTkRPV19CSVRTKVxuICBpZiAoc3RhdHVzICE9PSBaX09LKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQcm9ibGVtIGluaXRpYWxpemluZyBpbmZsYXRlIHN0cmVhbTogJyArIG1lc3NhZ2VzW3N0YXR1c10pXG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZW1pdCgpXG5cbiAgICBsZXQgc3RhcnRcbiAgICBzdHJlYW0uaW5wdXQgPSBkYXRhXG4gICAgc3RyZWFtLm5leHRfaW4gPSAwXG4gICAgc3RyZWFtLmF2YWlsX2luID0gc3RyZWFtLmlucHV0Lmxlbmd0aFxuXG4gICAgbGV0IHN0YXR1cywgb3V0cHV0XG4gICAgbGV0IHJldCA9IHRydWVcblxuICAgIGRvIHtcbiAgICAgIGlmIChzdHJlYW0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHN0cmVhbS5vdXRwdXQgPSBuZXcgVWludDhBcnJheShDSFVOS19TSVpFKVxuICAgICAgICBzdGFydCA9IHN0cmVhbS5uZXh0X291dCA9IDBcbiAgICAgICAgc3RyZWFtLmF2YWlsX291dCA9IENIVU5LX1NJWkVcbiAgICAgIH1cblxuICAgICAgc3RhdHVzID0gaW5mbGF0ZShzdHJlYW0sIFpfTk9fRkxVU0gpXG4gICAgICBpZiAoc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBaX09LKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW5mbGF0ZSBwcm9ibGVtOiAnICsgbWVzc2FnZXNbc3RhdHVzXSlcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cmVhbS5uZXh0X291dCkge1xuICAgICAgICBpZiAoc3RyZWFtLmF2YWlsX291dCA9PT0gMCB8fCBzdGF0dXMgPT09IFpfU1RSRUFNX0VORCkge1xuICAgICAgICAgIG91dHB1dCA9IHN0cmVhbS5vdXRwdXQuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ID0gc3RyZWFtLm5leHRfb3V0KVxuICAgICAgICAgIHJldCA9IGVtaXQob3V0cHV0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSB3aGlsZSAoKHN0cmVhbS5hdmFpbF9pbiA+IDApICYmIHN0YXR1cyAhPT0gWl9TVFJFQU1fRU5EKVxuXG4gICAgaWYgKHN0cmVhbS5uZXh0X291dCA+IHN0YXJ0KSB7XG4gICAgICBvdXRwdXQgPSBzdHJlYW0ub3V0cHV0LnN1YmFycmF5KHN0YXJ0LCBzdGFydCA9IHN0cmVhbS5uZXh0X291dClcbiAgICAgIHJldCA9IGVtaXQob3V0cHV0KVxuICAgIH1cblxuICAgIHJldHVybiByZXRcbiAgfVxufVxuIl19